package config

import (
	"encoding/base64"
	"time"

	"github.com/BurntSushi/toml"
)

type RBodySizeLimiterSection struct {
	Enable        bool  `toml:"enable"`
	MaxRBodyBytes int64 `toml:"max_rbody_bytes"`
}

// Optional: do min/max clamping?
func DefaultRBodySizeLimiterSection() RBodySizeLimiterSection {
	return RBodySizeLimiterSection{
		Enable:        false,
		MaxRBodyBytes: 4096,
	}
}

type RBodySizeLimiterConfig struct {
	Register RBodySizeLimiterSection `toml:"register"`
	Login    RBodySizeLimiterSection `toml:"login"`
}

func DefaultRBodySizeLimiterConfig() RBodySizeLimiterConfig {
	return RBodySizeLimiterConfig{
		Register: DefaultRBodySizeLimiterSection(),
		Login:    DefaultRBodySizeLimiterSection(),
	}
}

type IPRateLimiterSection struct {
	Enable      bool `toml:"enable"`
	MaxRequests int  `toml:"max_requests"`
	WindowMS    int  `toml:"window_ms"`
}

func DefaultIPRateLimiterSection() IPRateLimiterSection {
	return IPRateLimiterSection{
		Enable:      false,
		MaxRequests: 10,
		WindowMS:    1000,
	}
}

type IPRateLimiterConfig struct {
	Register IPRateLimiterSection `toml:"register"`
	Login    IPRateLimiterSection `toml:"login"`
	Logout   IPRateLimiterSection `toml:"logout"`
	Profile  IPRateLimiterSection `toml:"profile"`
}

func DefaultIPRateLimiterConfig() IPRateLimiterConfig {
	return IPRateLimiterConfig{
		Register: DefaultIPRateLimiterSection(),
		Login:    DefaultIPRateLimiterSection(),
		Logout:   DefaultIPRateLimiterSection(),
		Profile:  DefaultIPRateLimiterSection(),
	}
}

type AccountPerIPLimiterConfig struct {
	Enable      bool `toml:"enable"`
	MaxAccounts int  `toml:"max_accounts"`
}

func DefaultAccountPerIPLimiterConfig() AccountPerIPLimiterConfig {
	return AccountPerIPLimiterConfig{
		Enable:      false,
		MaxAccounts: 7,
	}
}

type ProofOfWorkConfig struct {
	Enable     bool          `toml:"enable"`
	Difficulty uint8         `toml:"difficulty"`
	TTLSeconds time.Duration `toml:"ttl_seconds"`
	SecretKey  string        `toml:"secret_key"`
}

func DefaultProofOfWorkConfig() ProofOfWorkConfig {
	return ProofOfWorkConfig{
		Enable:     false,
		Difficulty: 20,
		TTLSeconds: 30,
		SecretKey:  "",
	}
}

type Config struct {
	RBodySizeLimiter    RBodySizeLimiterConfig    `toml:"rbody_size_limiter"`
	AccountPerIPLimiter AccountPerIPLimiterConfig `toml:"account_per_ip_limiter"`
	ProofOfWork         ProofOfWorkConfig         `toml:"proof_of_work"`
	IPRateLimiter       IPRateLimiterConfig       `toml:"ip_rate_limiter"`
	DBPath              string                    `toml:"dbpath"`
	Debug               bool                      `toml:"debug"`
}

func LoadConfig(path string) (Config, error) {
	cfg := Config{
		RBodySizeLimiter:    DefaultRBodySizeLimiterConfig(),
		IPRateLimiter:       DefaultIPRateLimiterConfig(),
		AccountPerIPLimiter: DefaultAccountPerIPLimiterConfig(),
		ProofOfWork:         DefaultProofOfWorkConfig(),
		// DBPath and Debug intentionally left to TOML/zero-value
		// Empty DBPath should fail loudly
	}

	if _, err := toml.DecodeFile(path, &cfg); err != nil {
		return Config{}, err
	}
	cfg.Validate()
	return cfg, nil
}

func (c *Config) Validate() {
	if c.ProofOfWork.Enable {
		if c.ProofOfWork.SecretKey == "" {
			panic("proof_of_work.secret_key is required when PoW is enabled")
		}

		key, err := base64.StdEncoding.DecodeString(c.ProofOfWork.SecretKey)
		if err != nil {
			panic("proof_of_work.secret_key must be valid base64")
		}

		if len(key) < 16 {
			panic("proof_of_work.secret_key must be at least 16 bytes after decoding")
		}

		c.ProofOfWork.SecretKey = base64.StdEncoding.EncodeToString(key)
	}
}
